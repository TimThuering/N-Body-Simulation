#ifndef N_BODY_SIMULATION_PARALLELOCTREETOPDOWNSUBTREES_HPP
#define N_BODY_SIMULATION_PARALLELOCTREETOPDOWNSUBTREES_HPP

#include "BarnesHutOctree.hpp"
#include "TimeMeasurement.hpp"

class ParallelOctreeTopDownSubtrees : public BarnesHutOctree {
public:
    // storage for flags indicating that the corresponding node is currently locked, i.e. some thread currently is inserting a body.
    std::vector<int> nodeIsLocked_vec;
    buffer<int> nodeIsLocked;

    // stores the nodeID of the root of the subtree each body belongs to
    std::vector<std::size_t> subtreeOfBody_vec;
    buffer<std::size_t> subtreeOfBody;

    // stores the nodeID of the root of the subtree each node belongs to
    std::vector<std::size_t> subtreeOfNode_vec;
    buffer<std::size_t> subtreeOfNode;

    // stores all bodies that still need to be inserted into the subtrees ordered by their corresponding subtrees
    std::vector<std::size_t> sortedBodies_vec;
    buffer<std::size_t> sortedBodies;

    // stores the amount of subtrees that were generated by buildOctreeToLevel()
    std::vector<std::size_t> subtreeCount_vec;
    buffer<std::size_t> subtreeCount;

    std::size_t numberOfSubtrees = 0;

    std::size_t nodeCountTopOfTree = 0;


    /*
     * This function implements the octree creation algorithm which follows a synchronized parallel insertion approach
     * and uses SYCL for parallelization. In contrast to ParallelOctreeTopDownSynchronized, it first builds the octree to
     * a certain level and determines the subtree of each body. After that it builds each subtree in parallel completely
     * independent of the other subtrees.
     */
    void buildOctree(queue &queue, buffer<double> &current_positions_x, buffer<double> &current_positions_y,
                     buffer<double> &current_positions_z, buffer<double> &masses, TimeMeasurement &timer) override;

    ParallelOctreeTopDownSubtrees();


private:
    /*
     * This function builds the octree up to a certain level and determines for each body, into which subtree it belongs.
     */
    void buildOctreeToLevel(queue &queue, buffer<double> &current_positions_x, buffer<double> &current_positions_y,
                            buffer<double> &current_positions_z, buffer<double> &masses);

    void prepareSubtrees(queue &queue, buffer<std::size_t> &bodyCountSubtree, buffer<std::size_t> &subtrees,
                         std::size_t nodeCount);

    void sortBodiesForSubtrees(queue &queue, buffer<std::size_t> &bodyCountSubtree, buffer<std::size_t> &subtrees,
                               buffer<std::size_t> &bodiesOfSubtreeStartIndex);

    /*
     * This function builds the subtrees which were determined in Phase 1 with buildOctreeToLevel().
     * Each subtree is build in parallel with a synchronized top-down approach.
     * The individual subtrees are completely independent of each other and are also build parallel to the other subtrees.
     */
    void buildSubtrees(queue &queue, buffer<double> &current_positions_x, buffer<double> &current_positions_y,
                       buffer<double> &current_positions_z, buffer<double> &masses,
                       buffer<std::size_t> &bodiesOfSubtreeStartIndex, buffer<std::size_t> &bodyCountSubtree,
                       buffer<std::size_t> &subtrees);

    /*
     * Computes the center of mass of all bodies in a cell of the octree. A cell in the octree is represented by a node.
     * This version can be used on GPUs.
     */
    void computeCenterOfMassSubtrees_GPU(queue &queue, buffer<double> &current_positions_x,
                                         buffer<double> &current_positions_y,
                                         buffer<double> &current_positions_z, buffer<double> &masses,
                                         buffer<std::size_t> &bodyCountSubtree, buffer<std::size_t> &subtrees);


};


#endif //N_BODY_SIMULATION_PARALLELOCTREETOPDOWNSUBTREES_HPP
